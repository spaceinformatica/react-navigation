{"version":3,"sources":["types.tsx"],"names":["PrivateValueStore"],"mappings":";;AA2HA,OAAO,MAAMA,iBAAN,CAAiC;AAAA;AAAA,0BAW5B,EAX4B;AAAA;;AAAA","sourcesContent":["import type * as React from 'react';\r\nimport type {\r\n  DefaultRouterOptions,\r\n  NavigationState,\r\n  NavigationAction,\r\n  InitialState,\r\n  PartialState,\r\n  Route,\r\n  ParamListBase,\r\n} from '@react-navigation/routers';\r\n\r\nexport type DefaultNavigatorOptions<\r\n  ScreenOptions extends {},\r\n  ParamList extends ParamListBase = ParamListBase\r\n> = DefaultRouterOptions<Extract<keyof ParamList, string>> & {\r\n  /**\r\n   * Children React Elements to extract the route configuration from.\r\n   * Only `Screen` components are supported as children.\r\n   */\r\n  children: React.ReactNode;\r\n  /**\r\n   * Default options for all screens under this navigator.\r\n   */\r\n  screenOptions?:\r\n    | ScreenOptions\r\n    | ((props: {\r\n        route: RouteProp<ParamList, keyof ParamList>;\r\n        navigation: any;\r\n      }) => ScreenOptions);\r\n};\r\n\r\nexport type EventMapBase = Record<\r\n  string,\r\n  { data?: any; canPreventDefault?: boolean }\r\n>;\r\n\r\nexport type EventMapCore<State extends NavigationState> = {\r\n  focus: { data: undefined };\r\n  blur: { data: undefined };\r\n  state: { data: { state: State } };\r\n  beforeRemove: { data: { action: NavigationAction }; canPreventDefault: true };\r\n};\r\n\r\nexport type EventArg<\r\n  EventName extends string,\r\n  CanPreventDefault extends boolean | undefined = false,\r\n  Data = undefined\r\n> = {\r\n  /**\r\n   * Type of the event (e.g. `focus`, `blur`)\r\n   */\r\n  readonly type: EventName;\r\n  readonly target?: string;\r\n} & (CanPreventDefault extends true\r\n  ? {\r\n      /**\r\n       * Whether `event.preventDefault()` was called on this event object.\r\n       */\r\n      readonly defaultPrevented: boolean;\r\n      /**\r\n       * Prevent the default action which happens on this event.\r\n       */\r\n      preventDefault(): void;\r\n    }\r\n  : {}) &\r\n  (undefined extends Data\r\n    ? { readonly data?: Readonly<Data> }\r\n    : { readonly data: Readonly<Data> });\r\n\r\nexport type EventListenerCallback<\r\n  EventMap extends EventMapBase,\r\n  EventName extends keyof EventMap\r\n> = (\r\n  e: EventArg<\r\n    Extract<EventName, string>,\r\n    EventMap[EventName]['canPreventDefault'],\r\n    EventMap[EventName]['data']\r\n  >\r\n) => void;\r\n\r\nexport type EventConsumer<EventMap extends EventMapBase> = {\r\n  /**\r\n   * Subscribe to events from the parent navigator.\r\n   *\r\n   * @param type Type of the event (e.g. `focus`, `blur`)\r\n   * @param callback Callback listener which is executed upon receiving the event.\r\n   */\r\n  addListener<EventName extends Extract<keyof EventMap, string>>(\r\n    type: EventName,\r\n    callback: EventListenerCallback<EventMap, EventName>\r\n  ): () => void;\r\n  removeListener<EventName extends Extract<keyof EventMap, string>>(\r\n    type: EventName,\r\n    callback: EventListenerCallback<EventMap, EventName>\r\n  ): void;\r\n};\r\n\r\nexport type EventEmitter<EventMap extends EventMapBase> = {\r\n  /**\r\n   * Emit an event to child screens.\r\n   *\r\n   * @param options.type Type of the event (e.g. `focus`, `blur`)\r\n   * @param [options.data] Optional information regarding the event.\r\n   * @param [options.target] Key of the target route which should receive the event.\r\n   * If not specified, all routes receive the event.\r\n   */\r\n  emit<EventName extends Extract<keyof EventMap, string>>(\r\n    options: {\r\n      type: EventName;\r\n      target?: string;\r\n    } & (EventMap[EventName]['canPreventDefault'] extends true\r\n      ? { canPreventDefault: true }\r\n      : {}) &\r\n      (undefined extends EventMap[EventName]['data']\r\n        ? { data?: EventMap[EventName]['data'] }\r\n        : { data: EventMap[EventName]['data'] })\r\n  ): EventArg<\r\n    EventName,\r\n    EventMap[EventName]['canPreventDefault'],\r\n    EventMap[EventName]['data']\r\n  >;\r\n};\r\n\r\nexport class PrivateValueStore<A, B, C> {\r\n  /**\r\n   * UGLY HACK! DO NOT USE THE TYPE!!!\r\n   *\r\n   * TypeScript requires a type to be used to be able to infer it.\r\n   * The type should exist as its own without any operations such as union.\r\n   * So we need to figure out a way to store this type in a property.\r\n   * The problem with a normal property is that it shows up in intelliSense.\r\n   * Adding private keyword works, but the annotation is stripped away in declaration.\r\n   * Turns out if we use an empty string, it doesn't show up in intelliSense.\r\n   */\r\n  protected ''?: { a: A; b: B; c: C };\r\n}\r\n\r\ntype NavigationHelpersCommon<\r\n  ParamList extends ParamListBase,\r\n  State extends NavigationState = NavigationState\r\n> = {\r\n  /**\r\n   * Dispatch an action or an update function to the router.\r\n   * The update function will receive the current state,\r\n   *\r\n   * @param action Action object or update function.\r\n   */\r\n  dispatch(\r\n    action: NavigationAction | ((state: State) => NavigationAction)\r\n  ): void;\r\n\r\n  /**\r\n   * Navigate to a route in current navigation tree.\r\n   *\r\n   * @param name Name of the route to navigate to.\r\n   * @param [params] Params object for the route.\r\n   */\r\n  navigate<RouteName extends keyof ParamList>(\r\n    ...args: undefined extends ParamList[RouteName]\r\n      ? [RouteName] | [RouteName, ParamList[RouteName]]\r\n      : [RouteName, ParamList[RouteName]]\r\n  ): void;\r\n\r\n  /**\r\n   * Navigate to a route in current navigation tree.\r\n   *\r\n   * @param route Object with `key` or `name` for the route to navigate to, and a `params` object.\r\n   */\r\n  navigate<RouteName extends keyof ParamList>(\r\n    route:\r\n      | { key: string; params?: ParamList[RouteName] }\r\n      | { name: RouteName; key?: string; params: ParamList[RouteName] }\r\n  ): void;\r\n\r\n  /**\r\n   * Reset the navigation state to the provided state.\r\n   *\r\n   * @param state Navigation state object.\r\n   */\r\n  reset(state: PartialState<State> | State): void;\r\n\r\n  /**\r\n   * Go back to the previous route in history.\r\n   */\r\n  goBack(): void;\r\n\r\n  /**\r\n   * Check if the screen is focused. The method returns `true` if focused, `false` otherwise.\r\n   * Note that this method doesn't re-render screen when the focus changes. So don't use it in `render`.\r\n   * To get notified of focus changes, use `addListener('focus', cb)` and `addListener('blur', cb)`.\r\n   * To conditionally render content based on focus state, use the `useIsFocused` hook.\r\n   */\r\n  isFocused(): boolean;\r\n\r\n  /**\r\n   * Check if dispatching back action will be handled by navigation.\r\n   * Note that this method doesn't re-render screen when the result changes. So don't use it in `render`.\r\n   */\r\n  canGoBack(): boolean;\r\n\r\n  /**\r\n   * Returns the parent navigator, if any. Reason why the function is called\r\n   * dangerouslyGetParent is to warn developers against overusing it to eg. get parent\r\n   * of parent and other hard-to-follow patterns.\r\n   */\r\n  dangerouslyGetParent<T = NavigationProp<ParamListBase> | undefined>(): T;\r\n\r\n  /**\r\n   * Returns the navigator's state. Reason why the function is called\r\n   * dangerouslyGetState is to discourage developers to use internal navigation's state.\r\n   * Note that this method doesn't re-render screen when the result changes. So don't use it in `render`.\r\n   */\r\n  dangerouslyGetState(): State;\r\n} & PrivateValueStore<ParamList, keyof ParamList, {}>;\r\n\r\nexport type NavigationHelpers<\r\n  ParamList extends ParamListBase,\r\n  EventMap extends EventMapBase = {}\r\n> = NavigationHelpersCommon<ParamList> &\r\n  EventEmitter<EventMap> & {\r\n    /**\r\n     * Update the param object for the route.\r\n     * The new params will be shallow merged with the old one.\r\n     *\r\n     * @param params Params object for the current route.\r\n     */\r\n    setParams<RouteName extends keyof ParamList>(\r\n      params: Partial<ParamList[RouteName]>\r\n    ): void;\r\n  };\r\n\r\nexport type NavigationContainerProps = {\r\n  /**\r\n   * Initial navigation state for the child navigators.\r\n   */\r\n  initialState?: InitialState;\r\n  /**\r\n   * Callback which is called with the latest navigation state when it changes.\r\n   */\r\n  onStateChange?: (state: NavigationState | undefined) => void;\r\n  /**\r\n   * Callback which is called when an action is not handled.\r\n   */\r\n  onUnhandledAction?: (action: NavigationAction) => void;\r\n  /**\r\n   * Whether this navigation container should be independent of parent containers.\r\n   * If this is not set to `true`, this container cannot be nested inside another container.\r\n   * Setting it to `true` disconnects any children navigators from parent container.\r\n   */\r\n  independent?: boolean;\r\n  /**\r\n   * Children elements to render.\r\n   */\r\n  children: React.ReactNode;\r\n};\r\n\r\nexport type NavigationProp<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList = string,\r\n  State extends NavigationState = NavigationState<ParamList>,\r\n  ScreenOptions extends {} = {},\r\n  EventMap extends EventMapBase = {}\r\n> = NavigationHelpersCommon<ParamList, State> & {\r\n  /**\r\n   * Update the param object for the route.\r\n   * The new params will be shallow merged with the old one.\r\n   *\r\n   * @param params Params object for the current route.\r\n   */\r\n  setParams(params: Partial<ParamList[RouteName]>): void;\r\n\r\n  /**\r\n   * Update the options for the route.\r\n   * The options object will be shallow merged with default options object.\r\n   *\r\n   * @param options Options object for the route.\r\n   */\r\n  setOptions(options: Partial<ScreenOptions>): void;\r\n} & EventConsumer<EventMap & EventMapCore<State>> &\r\n  PrivateValueStore<ParamList, RouteName, EventMap>;\r\n\r\nexport type RouteProp<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList\r\n> = Route<Extract<RouteName, string>, ParamList[RouteName]>;\r\n\r\nexport type CompositeNavigationProp<\r\n  A extends NavigationProp<ParamListBase, string, any, any>,\r\n  B extends NavigationHelpersCommon<ParamListBase, any>\r\n> = Omit<A & B, keyof NavigationProp<any>> &\r\n  NavigationProp<\r\n    /**\r\n     * Param list from both navigation objects needs to be combined\r\n     * For example, we should be able to navigate to screens in both A and B\r\n     */\r\n    (A extends NavigationHelpersCommon<infer T> ? T : never) &\r\n      (B extends NavigationHelpersCommon<infer U> ? U : never),\r\n    /**\r\n     * The route name should refer to the route name specified in the first type\r\n     * Ideally it should work for any of them, but it's not possible to infer that way\r\n     */\r\n    A extends NavigationProp<any, infer R> ? R : string,\r\n    /**\r\n     * The type of state should refer to the state specified in the first type\r\n     */\r\n    A extends NavigationProp<any, any, infer S> ? S : NavigationState,\r\n    /**\r\n     * Screen options from both navigation objects needs to be combined\r\n     * This allows typechecking `setOptions`\r\n     */\r\n    (A extends NavigationProp<any, any, any, infer O> ? O : {}) &\r\n      (B extends NavigationProp<any, any, any, infer P> ? P : {}),\r\n    /**\r\n     * Event consumer config should refer to the config specified in the first type\r\n     * This allows typechecking `addListener`/`removeListener`\r\n     */\r\n    A extends NavigationProp<any, any, any, any, infer E> ? E : {}\r\n  >;\r\n\r\nexport type Descriptor<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList = string,\r\n  State extends NavigationState = NavigationState,\r\n  ScreenOptions extends {} = {},\r\n  EventMap extends EventMapBase = {}\r\n> = {\r\n  /**\r\n   * Render the component associated with this route.\r\n   */\r\n  render(): JSX.Element;\r\n\r\n  /**\r\n   * Options for the route.\r\n   */\r\n  options: ScreenOptions;\r\n\r\n  /**\r\n   * Navigation object for the screen\r\n   */\r\n  navigation: NavigationProp<\r\n    ParamList,\r\n    RouteName,\r\n    State,\r\n    ScreenOptions,\r\n    EventMap\r\n  >;\r\n};\r\n\r\nexport type ScreenListeners<\r\n  State extends NavigationState,\r\n  EventMap extends EventMapBase\r\n> = Partial<\r\n  {\r\n    [EventName in keyof (EventMap &\r\n      EventMapCore<State>)]: EventListenerCallback<EventMap, EventName>;\r\n  }\r\n>;\r\n\r\nexport type RouteConfig<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase\r\n> = {\r\n  /**\r\n   * Route name of this screen.\r\n   */\r\n  name: RouteName;\r\n\r\n  /**\r\n   * Navigator options for this screen.\r\n   */\r\n  options?:\r\n    | ScreenOptions\r\n    | ((props: {\r\n        route: RouteProp<ParamList, RouteName>;\r\n        navigation: any;\r\n      }) => ScreenOptions);\r\n\r\n  /**\r\n   * Event listeners for this screen.\r\n   */\r\n  listeners?:\r\n    | ScreenListeners<State, EventMap>\r\n    | ((props: {\r\n        route: RouteProp<ParamList, RouteName>;\r\n        navigation: any;\r\n      }) => ScreenListeners<State, EventMap>);\r\n\r\n  /**\r\n   * Function to return an unique ID for this screen.\r\n   * Receives an object with the route params.\r\n   * For a given screen name, there will always be only one screen corresponding to an ID.\r\n   * If `undefined` is returned, it acts same as no `getId` being specified.\r\n   */\r\n  getId?: ({ params }: { params: ParamList[RouteName] }) => string | undefined;\r\n\r\n  /**\r\n   * Initial params object for the route.\r\n   */\r\n  initialParams?: Partial<ParamList[RouteName]>;\r\n} & (\r\n  | {\r\n      /**\r\n       * React component to render for this screen.\r\n       */\r\n      component: React.ComponentType<any>;\r\n      getComponent?: never;\r\n      children?: never;\r\n    }\r\n  | {\r\n      /**\r\n       * Lazily get a React component to render for this screen.\r\n       */\r\n      getComponent: () => React.ComponentType<any>;\r\n      component?: never;\r\n      children?: never;\r\n    }\r\n  | {\r\n      /**\r\n       * Render callback to render content of this screen.\r\n       */\r\n      children: (props: {\r\n        route: RouteProp<ParamList, RouteName>;\r\n        navigation: any;\r\n      }) => React.ReactNode;\r\n      component?: never;\r\n      getComponent?: never;\r\n    }\r\n);\r\n\r\nexport type NavigationContainerEventMap = {\r\n  /**\r\n   * Event which fires when the navigation state changes.\r\n   */\r\n  state: {\r\n    data: {\r\n      /**\r\n       * The updated state object after the state change.\r\n       */\r\n      state: NavigationState | PartialState<NavigationState> | undefined;\r\n    };\r\n  };\r\n  /**\r\n   * Event which fires when current options changes.\r\n   */\r\n  options: { data: { options: object } };\r\n  /**\r\n   * Event which fires when an action is dispatched.\r\n   * Only intended for debugging purposes, don't use it for app logic.\r\n   * This event will be emitted before state changes have been applied.\r\n   */\r\n  __unsafe_action__: {\r\n    data: {\r\n      /**\r\n       * The action object which was dispatched.\r\n       */\r\n      action: NavigationAction;\r\n      /**\r\n       * Whether the action was a no-op, i.e. resulted any state changes.\r\n       */\r\n      noop: boolean;\r\n    };\r\n  };\r\n};\r\n\r\nexport type NavigationContainerRef = NavigationHelpers<ParamListBase> &\r\n  EventConsumer<NavigationContainerEventMap> & {\r\n    /**\r\n     * Reset the navigation state of the root navigator to the provided state.\r\n     *\r\n     * @param state Navigation state object.\r\n     */\r\n    resetRoot(state?: PartialState<NavigationState> | NavigationState): void;\r\n    /**\r\n     * Get the rehydrated navigation state of the navigation tree.\r\n     */\r\n    getRootState(): NavigationState;\r\n    /**\r\n     * Get the currently focused navigation route.\r\n     */\r\n    getCurrentRoute(): Route<string> | undefined;\r\n    /**\r\n     * Get the currently focused route's options.\r\n     */\r\n    getCurrentOptions(): object | undefined;\r\n  };\r\n\r\nexport type TypedNavigator<\r\n  ParamList extends ParamListBase,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase,\r\n  Navigator extends React.ComponentType<any>\r\n> = {\r\n  /**\r\n   * Navigator component which manages the child screens.\r\n   */\r\n  Navigator: React.ComponentType<\r\n    Omit<\r\n      React.ComponentProps<Navigator>,\r\n      keyof DefaultNavigatorOptions<any, any>\r\n    > &\r\n      DefaultNavigatorOptions<ScreenOptions, ParamList>\r\n  >;\r\n  /**\r\n   * Component used for specifying route configuration.\r\n   */\r\n  Screen: <RouteName extends keyof ParamList>(\r\n    _: RouteConfig<ParamList, RouteName, State, ScreenOptions, EventMap>\r\n  ) => null;\r\n};\r\n\r\nexport type NavigatorScreenParams<\r\n  ParamList,\r\n  State extends NavigationState = NavigationState\r\n> =\r\n  | {\r\n      screen?: never;\r\n      params?: never;\r\n      initial?: never;\r\n      state: PartialState<State> | State | undefined;\r\n    }\r\n  | {\r\n      [RouteName in keyof ParamList]: undefined extends ParamList[RouteName]\r\n        ? {\r\n            screen: RouteName;\r\n            params?: ParamList[RouteName];\r\n            initial?: boolean;\r\n            state?: never;\r\n          }\r\n        : {\r\n            screen: RouteName;\r\n            params: ParamList[RouteName];\r\n            initial?: boolean;\r\n            state?: never;\r\n          };\r\n    }[keyof ParamList];\r\n\r\nexport type PathConfig = {\r\n  path?: string;\r\n  exact?: boolean;\r\n  parse?: Record<string, (value: string) => any>;\r\n  stringify?: Record<string, (value: any) => string>;\r\n  screens?: PathConfigMap;\r\n  initialRouteName?: string;\r\n};\r\n\r\nexport type PathConfigMap = {\r\n  [routeName: string]: string | PathConfig;\r\n};\r\n"]}