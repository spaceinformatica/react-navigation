{"version":3,"sources":["checkLegacyPathConfig.tsx"],"names":["checkLegacyPathConfig","config","legacy","Object","keys","some","key","hasOwnProperty","Error","screens"],"mappings":"AAOA,eAAe,SAASA,qBAAT,CACbC,MADa,EAEmB;AAChC,MAAIC,MAAM,GAAG,KAAb;;AAEA,MAAID,MAAJ,EAAY;AACV;AACAC,IAAAA,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYH,MAAZ,EAAoBI,IAApB,CACNC,GAAD,IAASA,GAAG,KAAK,SAAR,IAAqBA,GAAG,KAAK,kBAD/B,CAAT;;AAIA,QACEJ,MAAM,KACLD,MAAM,CAACM,cAAP,CAAsB,SAAtB,KACCN,MAAM,CAACM,cAAP,CAAsB,kBAAtB,CAFI,CADR,EAIE;AACA,YAAM,IAAIC,KAAJ,CACJ,oKADI,CAAN;AAGD;AACF;;AAED,MAAIN,MAAJ,EAAY;AACV;AACA,WAAO,CAACA,MAAD,EAAS;AAAEO,MAAAA,OAAO,EAAER;AAAX,KAAT,CAAP;AACD;;AAED,SAAO,CAACC,MAAD,EAASD,MAAT,CAAP;AACD","sourcesContent":["import type { PathConfigMap } from './types';\r\n\r\ntype Options = {\r\n  initialRouteName?: string;\r\n  screens: PathConfigMap;\r\n};\r\n\r\nexport default function checkLegacyPathConfig(\r\n  config?: Options\r\n): [boolean, Options | undefined] {\r\n  let legacy = false;\r\n\r\n  if (config) {\r\n    // Assume legacy configuration if config has any other keys except `screens` and `initialRouteName`\r\n    legacy = Object.keys(config).some(\r\n      (key) => key !== 'screens' && key !== 'initialRouteName'\r\n    );\r\n\r\n    if (\r\n      legacy &&\r\n      (config.hasOwnProperty('screens') ||\r\n        config.hasOwnProperty('initialRouteName'))\r\n    ) {\r\n      throw new Error(\r\n        'Found invalid keys in the configuration object. See https://reactnavigation.org/docs/configuring-links/ for more details on the shape of the configuration object.'\r\n      );\r\n    }\r\n  }\r\n\r\n  if (legacy) {\r\n    // @ts-expect-error: we have incorrect type for config since we don't type legacy config\r\n    return [legacy, { screens: config }];\r\n  }\r\n\r\n  return [legacy, config];\r\n}\r\n"]}