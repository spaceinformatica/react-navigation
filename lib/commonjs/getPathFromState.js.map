{"version":3,"sources":["getPathFromState.tsx"],"names":["getActiveRoute","state","route","index","routes","length","getPathFromState","options","Error","legacy","compatOptions","configs","createNormalizedConfigs","screens","path","current","allParams","pattern","focusedParams","focusedRoute","currentOptions","nestedRouteNames","hasNext","name","push","params","stringify","currentParams","fromEntries","Object","entries","map","key","value","String","assign","split","filter","p","startsWith","forEach","getParamName","undefined","nextRoute","nestedConfig","join","endsWith","encodeURIComponent","param","query","queryString","replace","reduce","acc","k","v","hasOwnProperty","joinPaths","paths","concat","Boolean","createConfigItem","config","parentPattern","exact","c","result"],"mappings":"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","sourcesContent":["import * as queryString from 'query-string';\r\nimport type {\r\n  NavigationState,\r\n  PartialState,\r\n  Route,\r\n} from '@react-navigation/routers';\r\nimport checkLegacyPathConfig from './checkLegacyPathConfig';\r\nimport type { PathConfig, PathConfigMap } from './types';\r\n\r\ntype Options = { initialRouteName?: string; screens: PathConfigMap };\r\n\r\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\r\n\r\ntype StringifyConfig = Record<string, (value: any) => string>;\r\n\r\ntype ConfigItem = {\r\n  pattern?: string;\r\n  stringify?: StringifyConfig;\r\n  screens?: Record<string, ConfigItem>;\r\n};\r\n\r\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\r\n  const route =\r\n    typeof state.index === 'number'\r\n      ? state.routes[state.index]\r\n      : state.routes[state.routes.length - 1];\r\n\r\n  if (route.state) {\r\n    return getActiveRoute(route.state);\r\n  }\r\n\r\n  return route;\r\n};\r\n\r\n/**\r\n * Utility to serialize a navigation state object to a path string.\r\n *\r\n * @example\r\n * ```js\r\n * getPathFromState(\r\n *   {\r\n *     routes: [\r\n *       {\r\n *         name: 'Chat',\r\n *         params: { author: 'Jane', id: 42 },\r\n *       },\r\n *     ],\r\n *   },\r\n *   {\r\n *     screens: {\r\n *       Chat: {\r\n *         path: 'chat/:author/:id',\r\n *         stringify: { author: author => author.toLowerCase() }\r\n *       }\r\n *     }\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @param state Navigation state to serialize.\r\n * @param options Extra options to fine-tune how to serialize the path.\r\n * @returns Path representing the state, e.g. /foo/bar?count=42.\r\n */\r\nexport default function getPathFromState(\r\n  state: State,\r\n  options?: Options\r\n): string {\r\n  if (state == null) {\r\n    throw Error(\r\n      \"Got 'undefined' for the navigation state. You must pass a valid state object.\"\r\n    );\r\n  }\r\n\r\n  const [legacy, compatOptions] = checkLegacyPathConfig(options);\r\n\r\n  // Create a normalized configs object which will be easier to use\r\n  const configs: Record<string, ConfigItem> = compatOptions\r\n    ? createNormalizedConfigs(legacy, compatOptions.screens)\r\n    : {};\r\n\r\n  let path = '/';\r\n  let current: State | undefined = state;\r\n\r\n  const allParams: Record<string, any> = {};\r\n\r\n  while (current) {\r\n    let index = typeof current.index === 'number' ? current.index : 0;\r\n    let route = current.routes[index] as Route<string> & {\r\n      state?: State;\r\n    };\r\n\r\n    let pattern: string | undefined;\r\n\r\n    let focusedParams: Record<string, any> | undefined;\r\n    let focusedRoute = getActiveRoute(state);\r\n    let currentOptions = configs;\r\n\r\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\r\n    let nestedRouteNames = [];\r\n\r\n    let hasNext = true;\r\n\r\n    while (route.name in currentOptions && hasNext) {\r\n      pattern = currentOptions[route.name].pattern;\r\n\r\n      nestedRouteNames.push(route.name);\r\n\r\n      if (route.params) {\r\n        const stringify = currentOptions[route.name]?.stringify;\r\n\r\n        const currentParams = fromEntries(\r\n          Object.entries(route.params).map(([key, value]) => [\r\n            key,\r\n            stringify?.[key] ? stringify[key](value) : String(value),\r\n          ])\r\n        );\r\n\r\n        if (pattern) {\r\n          Object.assign(allParams, currentParams);\r\n        }\r\n\r\n        if (focusedRoute === route) {\r\n          // If this is the focused route, keep the params for later use\r\n          // We save it here since it's been stringified already\r\n          focusedParams = { ...currentParams };\r\n\r\n          pattern\r\n            ?.split('/')\r\n            .filter((p) => p.startsWith(':'))\r\n            // eslint-disable-next-line no-loop-func\r\n            .forEach((p) => {\r\n              const name = getParamName(p);\r\n\r\n              // Remove the params present in the pattern since we'll only use the rest for query string\r\n              if (focusedParams) {\r\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\r\n                delete focusedParams[name];\r\n              }\r\n            });\r\n        }\r\n      }\r\n\r\n      // If there is no `screens` property or no nested state, we return pattern\r\n      if (!currentOptions[route.name].screens || route.state === undefined) {\r\n        hasNext = false;\r\n      } else {\r\n        index =\r\n          typeof route.state.index === 'number'\r\n            ? route.state.index\r\n            : route.state.routes.length - 1;\r\n\r\n        const nextRoute = route.state.routes[index];\r\n        const nestedConfig = currentOptions[route.name].screens;\r\n\r\n        // if there is config for next route name, we go deeper\r\n        if (nestedConfig && nextRoute.name in nestedConfig) {\r\n          route = nextRoute as Route<string> & { state?: State };\r\n          currentOptions = nestedConfig;\r\n        } else {\r\n          // If not, there is no sense in going deeper in config\r\n          hasNext = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (pattern === undefined) {\r\n      pattern = nestedRouteNames.join('/');\r\n    }\r\n\r\n    if (currentOptions[route.name] !== undefined) {\r\n      path += pattern\r\n        .split('/')\r\n        .map((p) => {\r\n          const name = getParamName(p);\r\n\r\n          // We don't know what to show for wildcard patterns\r\n          // Showing the route name seems ok, though whatever we show here will be incorrect\r\n          // Since the page doesn't actually exist\r\n          if (p === '*') {\r\n            if (legacy) {\r\n              throw new Error(\r\n                \"Please update your config to the new format to use wildcard pattern ('*'). https://reactnavigation.org/docs/configuring-links/#updating-config\"\r\n              );\r\n            }\r\n\r\n            return route.name;\r\n          }\r\n\r\n          // If the path has a pattern for a param, put the param in the path\r\n          if (p.startsWith(':')) {\r\n            const value = allParams[name];\r\n\r\n            if (value === undefined && p.endsWith('?')) {\r\n              // Optional params without value assigned in route.params should be ignored\r\n              return '';\r\n            }\r\n\r\n            return encodeURIComponent(value);\r\n          }\r\n\r\n          return encodeURIComponent(p);\r\n        })\r\n        .join('/');\r\n    } else {\r\n      path += encodeURIComponent(route.name);\r\n    }\r\n\r\n    if (!focusedParams) {\r\n      focusedParams = focusedRoute.params;\r\n    }\r\n\r\n    if (route.state) {\r\n      path += '/';\r\n    } else if (focusedParams) {\r\n      for (let param in focusedParams) {\r\n        if (focusedParams[param] === 'undefined') {\r\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\r\n          delete focusedParams[param];\r\n        }\r\n      }\r\n\r\n      const query = queryString.stringify(focusedParams);\r\n\r\n      if (query) {\r\n        path += `?${query}`;\r\n      }\r\n    }\r\n\r\n    current = route.state;\r\n  }\r\n\r\n  // Remove multiple as well as trailing slashes\r\n  path = path.replace(/\\/+/g, '/');\r\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\r\n\r\n  return path;\r\n}\r\n\r\n// Object.fromEntries is not available in older iOS versions\r\nconst fromEntries = <K extends string, V>(entries: (readonly [K, V])[]) =>\r\n  entries.reduce((acc, [k, v]) => {\r\n    if (acc.hasOwnProperty(k)) {\r\n      throw new Error(`A value for key '${k}' already exists in the object.`);\r\n    }\r\n\r\n    acc[k] = v;\r\n    return acc;\r\n  }, {} as Record<K, V>);\r\n\r\nconst getParamName = (pattern: string) =>\r\n  pattern.replace(/^:/, '').replace(/\\?$/, '');\r\n\r\nconst joinPaths = (...paths: string[]): string =>\r\n  ([] as string[])\r\n    .concat(...paths.map((p) => p.split('/')))\r\n    .filter(Boolean)\r\n    .join('/');\r\n\r\nconst createConfigItem = (\r\n  legacy: boolean,\r\n  config: PathConfig | string,\r\n  parentPattern?: string\r\n): ConfigItem => {\r\n  if (typeof config === 'string') {\r\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\r\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\r\n\r\n    return { pattern };\r\n  }\r\n\r\n  // If an object is specified as the value (e.g. Foo: { ... }),\r\n  // It can have `path` property and `screens` prop which has nested configs\r\n  let pattern: string | undefined;\r\n\r\n  if (legacy) {\r\n    pattern =\r\n      config.exact !== true && parentPattern && config.path\r\n        ? joinPaths(parentPattern, config.path)\r\n        : config.path;\r\n  } else {\r\n    if (config.exact && config.path === undefined) {\r\n      throw new Error(\r\n        \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\r\n      );\r\n    }\r\n\r\n    pattern =\r\n      config.exact !== true\r\n        ? joinPaths(parentPattern || '', config.path || '')\r\n        : config.path || '';\r\n  }\r\n\r\n  const screens = config.screens\r\n    ? createNormalizedConfigs(legacy, config.screens, pattern)\r\n    : undefined;\r\n\r\n  return {\r\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\r\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\r\n    stringify: config.stringify,\r\n    screens,\r\n  };\r\n};\r\n\r\nconst createNormalizedConfigs = (\r\n  legacy: boolean,\r\n  options: PathConfigMap,\r\n  pattern?: string\r\n): Record<string, ConfigItem> =>\r\n  fromEntries(\r\n    Object.entries(options).map(([name, c]) => {\r\n      const result = createConfigItem(legacy, c, pattern);\r\n\r\n      return [name, result];\r\n    })\r\n  );\r\n"]}